"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = exports.Where = exports.Query = exports.isSQLFunction = exports.SQLFunc = exports.NativeFunction = exports.TableSchema = exports.isJSONType = exports.JSONType = exports.ForeignKeyUpdateDeleteRule = exports.ColumnType = exports.PArray = exports.isCollection = void 0;
const sql_1 = require("./sql");
const util_1 = require("util");
const isCollection = (obj) => obj.collection === "array";
exports.isCollection = isCollection;
const PArray = (type) => ({ collection: "array", type });
exports.PArray = PArray;
var ColumnType;
(function (ColumnType) {
    ColumnType["BigInt"] = "bigint";
    ColumnType["Boolean"] = "boolean";
    ColumnType["Varchar"] = "varchar";
    ColumnType["Date"] = "date";
    ColumnType["Integer"] = "integer";
    ColumnType["Text"] = "text";
    ColumnType["Timestamp"] = "timestamp";
    ColumnType["TimestampTZ"] = "timestamptz";
    ColumnType["UUID"] = "uuid";
})(ColumnType = exports.ColumnType || (exports.ColumnType = {}));
var ForeignKeyUpdateDeleteRule;
(function (ForeignKeyUpdateDeleteRule) {
    ForeignKeyUpdateDeleteRule[ForeignKeyUpdateDeleteRule["Cascade"] = 0] = "Cascade";
    ForeignKeyUpdateDeleteRule[ForeignKeyUpdateDeleteRule["Restrict"] = 1] = "Restrict";
    ForeignKeyUpdateDeleteRule[ForeignKeyUpdateDeleteRule["SetNull"] = 2] = "SetNull";
    ForeignKeyUpdateDeleteRule[ForeignKeyUpdateDeleteRule["NoAction"] = 3] = "NoAction";
    ForeignKeyUpdateDeleteRule[ForeignKeyUpdateDeleteRule["SetDefault"] = 4] = "SetDefault";
})(ForeignKeyUpdateDeleteRule = exports.ForeignKeyUpdateDeleteRule || (exports.ForeignKeyUpdateDeleteRule = {}));
const JSONType = () => ({ json: true });
exports.JSONType = JSONType;
const isJSONType = (type) => typeof type === "object" && type.json === true;
exports.isJSONType = isJSONType;
const TableSchema = (columns) => columns;
exports.TableSchema = TableSchema;
var NativeFunction;
(function (NativeFunction) {
    NativeFunction["Now"] = "now()";
})(NativeFunction = exports.NativeFunction || (exports.NativeFunction = {}));
const SQLFunc = (cqlFunction) => ({
    func: cqlFunction,
});
exports.SQLFunc = SQLFunc;
const isSQLFunction = (value) => typeof value.func === "string";
exports.isSQLFunction = isSQLFunction;
const Query = (sql, values) => ({ sql, values });
exports.Query = Query;
const isWhereCondition = (obj) => typeof obj === "object" && obj.type === "where_filter";
exports.Where = {
    isNull: () => ({
        type: "where_filter",
        sql: "IS NULL",
    }),
    isNotNull: () => ({
        type: "where_filter",
        sql: "IS NOT NULL",
    }),
};
const Table = (tables, table) => {
    const columns = tables[table];
    return {
        name: table,
        create: () => ({
            sql: sql_1.SQL.createTable(table, columns),
        }),
        insert: (subset) => (values) => ({
            sql: sql_1.SQL.insert(table, subset.filter(util_1.isString)),
            values,
        }),
        insertFromObj: (obj) => {
            const subset = Object.keys(obj);
            const values = Object.values(obj);
            return {
                sql: sql_1.SQL.insert(table, subset),
                values,
            };
        },
        update: (subset, where) => (subsetValues, whereValues) => ({
            sql: sql_1.SQL.update(table, subset.filter(util_1.isString), where.filter(util_1.isString)),
            values: [...subsetValues, ...whereValues],
        }),
        selectAll: (subset) => {
            const sql = subset === "*" ? sql_1.SQL.selectAll(table, subset) : sql_1.SQL.selectAll(table, subset.filter(util_1.isString));
            return {
                sql,
            };
        },
        select: (subset, where) => (values) => {
            const whereSubstitutions = new Map();
            const whereStringValued = where.filter(util_1.isString);
            const finalValues = values.filter((value, idx) => {
                if (isWhereCondition(value)) {
                    const whereCond = value;
                    whereSubstitutions.set(idx, Object.assign(Object.assign({}, whereCond), { column: whereStringValued[idx], toString: () => `${whereStringValued[idx]} ${whereCond.sql}` }));
                    return false;
                }
                return true;
            });
            const finalWhere = whereStringValued.map((where, idx) => {
                if (whereSubstitutions.has(idx)) {
                    return whereSubstitutions.get(idx);
                }
                return where;
            });
            const sql = subset === "*"
                ? sql_1.SQL.select(table, subset, finalWhere)
                : sql_1.SQL.select(table, subset.filter(util_1.isString), finalWhere);
            return {
                sql,
                values: finalValues,
            };
        },
        drop: () => ({
            sql: sql_1.SQL.dropTable(table),
        }),
        delete: (where) => {
            const sql = sql_1.SQL.deleteEntry(table, where.filter(util_1.isString));
            return (values) => ({
                sql,
                values,
            });
        },
        addColumns: (columns) => ({
            sql: sql_1.SQL.addColumns(table, columns),
        }),
        dropColumns: (columnsToRemove) => {
            const columnNames = columnsToRemove.filter(util_1.isString);
            const columndObject = columnNames.reduce((obj, columnName) => {
                const columnDefinition = columns[columnName];
                return Object.assign(Object.assign({}, obj), { [columnName]: columnDefinition });
            }, {});
            return {
                sql: sql_1.SQL.dropColumns(table, columndObject),
            };
        },
    };
};
exports.Table = Table;
//# sourceMappingURL=table.js.map