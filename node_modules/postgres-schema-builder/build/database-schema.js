"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaDiff = exports.DatabaseSchema = exports.Migration = void 0;
const table_1 = require("./table");
const sql_1 = require("./sql");
const lodash_max_1 = __importDefault(require("lodash.max"));
const bulk_prepared_statements_1 = require("./bulk-prepared-statements");
const schema_management = table_1.TableSchema({
    name: {
        type: table_1.ColumnType.Varchar,
        primaryKey: true,
        nullable: false,
        unique: true,
    },
    version: { type: table_1.ColumnType.Integer, nullable: false },
    date_added: {
        type: table_1.ColumnType.TimestampTZ,
        nullable: false,
        defaultValue: { func: table_1.NativeFunction.Now },
    },
    locked: { type: table_1.ColumnType.Boolean, nullable: false, defaultValue: false },
});
const SchemaManagementTable = table_1.Table({ schema_management }, "schema_management");
const selectVersionQuery = (name) => SchemaManagementTable.select("*", ["name"])([name]);
const insertSchemaQuery = (name, version) => SchemaManagementTable.insertFromObj({ name, version });
const updateSchemaVersionQuery = (name, newVersion) => SchemaManagementTable.update(["version"], ["name"])([newVersion], [name]);
const Migration = (up, views = []) => ({ up, views });
exports.Migration = Migration;
const DatabaseSchema = ({ client, createStatements, views, name, migrations, logMigrations, }) => {
    let version = 0;
    let isInitialized = false;
    const initialCreateViewsStatements = views.map((view) => view.create());
    const getLatestMigrationVersion = () => {
        return lodash_max_1.default(Array.from(migrations.keys())) || 1;
    };
    const init = () => __awaiter(void 0, void 0, void 0, function* () {
        if (isInitialized) {
            throw new Error(`Database schema ${name} has already been initialized.`);
        }
        try {
            yield client.transaction((transaction) => __awaiter(void 0, void 0, void 0, function* () {
                yield transaction.query(SchemaManagementTable.create());
                const versionDBResults = yield transaction.query(selectVersionQuery(name));
                if (versionDBResults.length === 0) {
                    const initialVersion = getLatestMigrationVersion();
                    yield transaction.query({
                        sql: createStatements.join("\n"),
                    });
                    yield transaction.query(insertSchemaQuery(name, initialVersion));
                    yield transaction.query({ sql: bulk_prepared_statements_1.bulkPreparedStatements(initialCreateViewsStatements) });
                    version = initialVersion;
                }
                else {
                    version = versionDBResults[0].version;
                }
            }));
        }
        catch (err) {
            if (err.message.indexOf("duplicate key value violates unique constraint") === -1) {
                throw err;
            }
        }
        isInitialized = true;
    });
    const throwNotInitialized = () => {
        throw new Error(`Migration failed, database schema is not initialized. Please call init() first on your database schema.`);
    };
    const lockSchemaTableQuery = sql_1.SQL.raw(`
                LOCK TABLE ${SchemaManagementTable.name} IN ACCESS EXCLUSIVE MODE;
            `, []);
    const getSchemaVersionQuery = (awaitLock) => sql_1.SQL.raw(`
                SELECT * FROM ${SchemaManagementTable.name}
                WHERE name = $1 ${!awaitLock ? "FOR UPDATE NOWAIT" : ""};
            `, [name]);
    const setSchemaLockQuery = (locked) => sql_1.SQL.raw(`
                UPDATE ${SchemaManagementTable.name} SET locked = $1 WHERE name=$2;
            `, [locked, name]);
    /*
        Locks schema_management table for given transaction and retrievs current schema version
        If table is already locked, the postgres client is advised to await execution until lock is released
        This ensures, that in a multi-node environment all starting nodes proceed code execution after all migrations are done
    */
    const getCurrentVersionAndLockSchema = (client, awaitLock) => __awaiter(void 0, void 0, void 0, function* () {
        yield client.query(lockSchemaTableQuery);
        const dbResults = yield client.query(getSchemaVersionQuery(awaitLock));
        if (dbResults.length === 1 && dbResults[0].locked === false) {
            yield client.query(setSchemaLockQuery(true));
            return dbResults[0].version;
        }
        return null;
    });
    const migrateToVersion = (targetVersion) => __awaiter(void 0, void 0, void 0, function* () {
        if (!isInitialized)
            throwNotInitialized();
        if (targetVersion <= 1) {
            throw new Error("Target version of migrateToVersion() has to be greater 1");
        }
        for (let newVersion = version; newVersion <= targetVersion; newVersion++) {
            yield client.transaction((transaction) => __awaiter(void 0, void 0, void 0, function* () {
                const currentVersion = yield getCurrentVersionAndLockSchema(transaction, true);
                if (currentVersion === null || currentVersion >= newVersion) {
                    if (currentVersion) {
                        yield transaction.query(setSchemaLockQuery(false));
                    }
                    return;
                }
                const migration = migrations.get(newVersion);
                const prevMigration = migrations.get(newVersion - 1);
                if (!migration) {
                    throw new Error(`Migration with version ${newVersion} not found. Aborting migration process...`);
                }
                if (newVersion > 2 && !prevMigration) {
                    throw new Error(`Migration with version ${newVersion - 1} not found. Aborting migration process...`);
                }
                const currentViews = migration.views;
                const prevViews = (prevMigration === null || prevMigration === void 0 ? void 0 : prevMigration.views) || [];
                const dropPrevViewsStatements = prevViews.map((view) => view.drop());
                const createCurrentViewsStatements = currentViews.map((view) => view.create());
                yield transaction.query({ sql: bulk_prepared_statements_1.bulkPreparedStatements(dropPrevViewsStatements) });
                const migrationQueries = yield migration.up({ transaction, database: client });
                if (Array.isArray(migrationQueries)) {
                    for (const migrationQuery of migrationQueries) {
                        yield transaction.query(migrationQuery);
                    }
                }
                yield transaction.query(updateSchemaVersionQuery(name, newVersion));
                yield transaction.query(setSchemaLockQuery(false));
                yield transaction.query({ sql: bulk_prepared_statements_1.bulkPreparedStatements(createCurrentViewsStatements) });
                // istanbul ignore next
                if (!(logMigrations === false)) {
                    console.info(`Successfully migrated ${name} from version ${version} to ${newVersion}`);
                }
            }));
            version = newVersion;
        }
    });
    const migrateLatest = () => __awaiter(void 0, void 0, void 0, function* () {
        const sortedMigrationKeys = Array.from(migrations.keys()).sort();
        const latestVersion = sortedMigrationKeys[sortedMigrationKeys.length - 1];
        yield migrateToVersion(latestVersion);
    });
    const getVersion = () => version;
    return {
        name,
        getVersion,
        init,
        migrateLatest,
        migrateToVersion,
    };
};
exports.DatabaseSchema = DatabaseSchema;
const SchemaDiff = (oldTables, tables) => {
    return {
        dropTable: (table) => sql_1.SQL.dropTable(table, true),
        createTable: (table) => sql_1.SQL.createTable(table, tables[table]),
        replaceTables: (replace) => [
            ...replace.map((table) => sql_1.SQL.dropTable(table, true)),
            ...[...replace].reverse().map((table) => sql_1.SQL.createTable(table, tables[table])),
        ],
        dropTableColumn: (table, column) => sql_1.SQL.dropTableColumn(table, column, true),
        addTableColumn: (table, column) => sql_1.SQL.addTableColumn(table, Object.assign({ name: column }, tables[table][column]), true),
        replaceTableColumn: (table, column) => [
            sql_1.SQL.dropTableColumn(table, column, true),
            sql_1.SQL.addTableColumn(table, Object.assign({ name: column }, tables[table][column]), true),
        ],
        addRequiredColumn: (table, column, updates) => [
            sql_1.SQL.addTableColumn(table, Object.assign(Object.assign({ name: column }, tables[table][column]), { nullable: true }), true),
            ...updates,
            sql_1.SQL.raw(`ALTER TABLE ${table} ALTER COLUMN ${column} SET NOT NULL;`).sql,
        ].join("\n"),
        replaceRequiredColumn: (table, column) => {
            const oldColumn = `__old_${column}`;
            return [
                sql_1.SQL.dropConstraint(table, column, oldTables[table][column]),
                sql_1.SQL.raw(`ALTER TABLE ${table} RENAME COLUMN ${column} TO ${oldColumn};`),
                sql_1.SQL.addTableColumn(table, Object.assign(Object.assign({ name: column }, tables[table][column]), { nullable: true }), true),
                sql_1.SQL.raw(`UPDATE ${table} SET ${column} = ${oldColumn}`),
                sql_1.SQL.raw(`ALTER TABLE ${table} ALTER COLUMN ${column} SET NOT NULL;`),
                sql_1.SQL.dropTableColumn(table, oldColumn, true),
            ];
        },
        addIndex: (table, column, unique) => sql_1.SQL.createIndex(unique, table, column),
    };
};
exports.SchemaDiff = SchemaDiff;
//# sourceMappingURL=database-schema.js.map