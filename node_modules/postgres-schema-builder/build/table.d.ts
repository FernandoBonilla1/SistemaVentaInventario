export interface Collection<T extends ColumnType> {
    type: T;
    collection: "array";
}
export declare const isCollection: (obj: any) => obj is Collection<ColumnType>;
export declare const PArray: <T extends ColumnType>(type: T) => Collection<T>;
export declare enum ColumnType {
    BigInt = "bigint",
    Boolean = "boolean",
    Varchar = "varchar",
    Date = "date",
    Integer = "integer",
    Text = "text",
    Timestamp = "timestamp",
    TimestampTZ = "timestamptz",
    UUID = "uuid"
}
export declare enum ForeignKeyUpdateDeleteRule {
    Cascade = 0,
    Restrict = 1,
    SetNull = 2,
    NoAction = 3,
    SetDefault = 4
}
export interface IReferenceConstraint {
    targetTable: string;
    targetColumn: string;
    onUpdate?: ForeignKeyUpdateDeleteRule;
    onDelete?: ForeignKeyUpdateDeleteRule;
}
export interface IReferenceConstraintInternal extends IReferenceConstraint {
    column: string;
}
export interface ICreateIndexStatement {
    table?: string;
    column: string;
    unique: boolean;
}
export interface Column {
    type: ColumnType | Collection<ColumnType> | IColumnTypeJson<unknown>;
    primaryKey?: boolean;
    defaultValue?: unknown | SQLFunction;
    nullable?: boolean;
    autoIncrement?: boolean;
    foreignKeys?: IReferenceConstraint[];
    createIndex?: boolean;
    unique?: boolean;
}
export interface Columns {
    [key: string]: Column;
}
export interface IColumnTypeJson<Type> {
    json: true;
    sample?: Type;
}
export declare const JSONType: <Type>() => IColumnTypeJson<Type>;
export declare const isJSONType: (type: any) => type is IColumnTypeJson<unknown>;
declare type BigInteger = BigInt | number;
export declare const TableSchema: <C extends Columns>(columns: C) => { [key in keyof C]: C[key]; };
declare type ColumnBaseType<C extends Column> = C extends {
    type: ColumnType.BigInt;
} ? BigInteger : C extends {
    type: ColumnType.Boolean;
} ? boolean : C extends {
    type: ColumnType.Varchar;
} ? string : C extends {
    type: ColumnType.Date;
} ? Date : C extends {
    type: ColumnType.Integer;
} ? number : C extends {
    type: ColumnType.Text;
} ? string : C extends {
    type: ColumnType.Timestamp;
} ? Date : C extends {
    type: ColumnType.TimestampTZ;
} ? Date : C extends {
    type: ColumnType.UUID;
} ? string : C extends {
    type: Collection<ColumnType.BigInt>;
} ? BigInteger[] : C extends {
    type: Collection<ColumnType.Boolean>;
} ? boolean[] : C extends {
    type: Collection<ColumnType.Varchar>;
} ? string[] : C extends {
    type: Collection<ColumnType.Date>;
} ? Date[] : C extends {
    type: Collection<ColumnType.Integer>;
} ? number[] : C extends {
    type: Collection<ColumnType.Text>;
} ? string[] : C extends {
    type: Collection<ColumnType.Timestamp>;
} ? Date[] : C extends {
    type: Collection<ColumnType.TimestampTZ>;
} ? Date[] : C extends {
    type: Collection<ColumnType.UUID>;
} ? string[] : C extends {
    type: IColumnTypeJson<unknown>;
} ? Required<C["type"]>["sample"] : unknown;
declare type ColumnTypeFinal<C extends Column> = C extends {
    primaryKey: true;
} ? ColumnBaseType<C> : C extends {
    defaultValue: {};
} ? ColumnBaseType<C> : C extends {
    nullable: false;
} ? ColumnBaseType<C> : ColumnBaseType<C> | null;
export declare type TableRecord<C extends Columns> = {
    -readonly [key in keyof C]: ColumnTypeFinal<C[key]>;
};
export declare enum NativeFunction {
    Now = "now()"
}
interface SQLFunction {
    func: NativeFunction | string;
}
export declare const SQLFunc: (cqlFunction: NativeFunction | string) => SQLFunction;
export declare const isSQLFunction: (value: any) => value is SQLFunction;
declare type ColumnValuesBase<C extends Columns, Subset extends (keyof C)[]> = {
    [key in keyof Subset]: TableRecord<C>[Extract<Subset[key], keyof C>] | SQLFunction | IWhereCondition;
};
declare type ColumnValues<C extends Columns, Subset extends (keyof C)[]> = ColumnValuesBase<C, Subset>[keyof Subset][] & ColumnValuesBase<C, Subset>;
export declare type IQuery<C extends Columns> = {
    sql: string;
    values?: unknown[];
    columns?: C;
};
export declare const Query: (sql: string, values?: unknown[] | undefined) => IQuery<{}>;
export interface ISQLArg {
    toString: () => string;
}
export interface IWhereCondition {
    type: "where_filter";
    sql: string;
}
export interface IWhereConditionColumned extends IWhereCondition, ISQLArg {
    column: string;
}
export declare const Where: {
    isNull: () => IWhereCondition;
    isNotNull: () => IWhereCondition;
};
declare type NonEmpty<Type> = [Type, ...Type[]];
export declare type Keys<C extends Columns> = (keyof C)[] & (NonEmpty<keyof C> | []);
export interface ITable<C extends Columns> {
    readonly name: string;
    create(): IQuery<{}>;
    insert<Subset extends Keys<C>>(subset: Subset): (values: ColumnValues<C, Subset>) => IQuery<{}>;
    insertFromObj<Subset extends TableRecord<C>>(obj: Partial<Subset>): IQuery<{}>;
    update<Subset extends Keys<C>, Where extends Keys<C>>(subset: Subset, where: Where): (subsetValues: ColumnValues<C, Subset>, whereValues: ColumnValues<C, Where>) => IQuery<{}>;
    selectAll<Subset extends Keys<C>>(subset: Subset | "*"): IQuery<Pick<C, Extract<Subset[number], string>>>;
    select<Subset extends Keys<C>, Where extends Keys<C>>(subset: Subset | "*", where: Where, allowFiltering?: boolean): (conditions: ColumnValues<C, Where>) => IQuery<Pick<C, Extract<Subset[number], string>>>;
    drop(): IQuery<{}>;
    delete<Where extends Keys<C>>(where: Where): (conditions: ColumnValues<C, Where>) => IQuery<{}>;
    addColumns(columns: Columns): IQuery<{}>;
    dropColumns<Subset extends Keys<C>>(columns: Subset): IQuery<{}>;
}
export declare const Table: <Tables extends {
    [key: string]: Columns;
}, Table extends Extract<keyof Tables, string>>(tables: Tables, table: Table) => ITable<Tables[Table]>;
export {};
