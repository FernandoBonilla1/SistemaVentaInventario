"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQL = void 0;
const table_1 = require("./table");
const pg_escape_1 = __importDefault(require("pg-escape"));
const sql_utils_1 = require("./sql-utils");
const moment_1 = __importDefault(require("moment"));
const utils_1 = require("./utils");
const isStringArray = (arr) => Array.isArray(arr) && arr.every((item) => typeof item === "string");
var SQL;
(function (SQL) {
    SQL.createDatabase = (name) => `CREATE DATABASE ${name};`;
    SQL.createTable = (name, columns) => {
        const entries = Object.entries(columns).map(([name, column]) => (Object.assign({ name }, column)));
        const foreignKeyConstraints = collectForeignKeyConstraints(entries);
        const primaryKeyColoumns = entries.filter((col) => {
            return col.primaryKey !== undefined && col.primaryKey;
        });
        if (primaryKeyColoumns.length === 0) {
            throw new Error(`Primary Key(s) missing. Cannot create table ${name}.`);
        }
        const createTableQuery = `
                CREATE TABLE IF NOT EXISTS ${name} (
				${entries
            .map(prepareCreateColumnStatement)
            .concat([
            `CONSTRAINT PK_${name}_${primaryKeyColoumns
                .map((pkc) => pkc.name)
                .join("_")} PRIMARY KEY (${primaryKeyColoumns.map((pkc) => `"${pkc.name}"`).join(",")})`,
        ])
            .concat(prepareForeignKeyConstraintStatements(name, foreignKeyConstraints).map((stmt) => `CONSTRAINT ${stmt}`))
            .join(",\n")}
            );
		`;
        const indexStatements = entries
            .filter((col) => {
            return (col.unique !== undefined && col.unique) || (col.createIndex !== undefined && col.createIndex);
        })
            .map((col) => {
            return {
                column: col.name,
                unique: col.unique !== undefined && col.unique,
            };
        });
        const createIndexQueries = indexStatements.map((indexStatement) => SQL.createIndex(indexStatement.unique, name, indexStatement.column));
        return `
			${createTableQuery}
			${createIndexQueries.join("\n")}
		`;
    };
    SQL.addColumns = (tableName, columns) => {
        const entries = Object.entries(columns).map(([name, column]) => (Object.assign({ name }, column)));
        const foreignKeyConstraints = collectForeignKeyConstraints(entries);
        const addForeignKeyConstraintsStatements = `
			${prepareForeignKeyConstraintStatements(tableName, foreignKeyConstraints)
            .map((constraint) => `ALTER TABLE ${tableName} ADD CONSTRAINT ${constraint}`)
            .join(";\n")}
		`;
        const addTableColumnStatement = `
			ALTER TABLE ${tableName}
			${entries.map((entry) => `ADD COLUMN ${prepareCreateColumnStatement(entry)}`).join(",\n")};
		`;
        return `
			${addTableColumnStatement}
			${addForeignKeyConstraintsStatements}
		`;
    };
    SQL.dropColumns = (tableName, columns, constraints) => {
        const columnNames = isStringArray(columns) ? columns : Object.keys(columns);
        let constraintNames = [];
        if (constraints && constraints.length > 0) {
            constraintNames = constraints;
        }
        else if (!isStringArray(columns)) {
            const entries = Object.entries(columns).map(([name, column]) => (Object.assign({ name }, column)));
            const foreignKeyConstraints = collectForeignKeyConstraints(entries);
            constraintNames = foreignKeyConstraints.map((fkc) => `${tableName}_${fkc.column}_fkey`);
        }
        const dropTableColumnsStatement = `
			ALTER TABLE ${tableName}
			${columnNames.map((column) => `DROP COLUMN ${column}`).join(",\n")};
		`;
        const dropConstraintsStatement = constraintNames
            .map((constraint) => `ALTER TABLE ${tableName} DROP CONSTRAINT ${constraint};`)
            .join("\n");
        return `
			${dropConstraintsStatement}
			${dropTableColumnsStatement}
		`;
    };
    SQL.insert = (tableName, subset) => {
        const cql = `INSERT INTO ${tableName}` +
            ` ( ${subset.map((column) => `"${column}"`).join(", ")} )` +
            ` VALUES ( ${subset.map((_, idx) => `$${idx + 1}`).join(", ")} );`;
        return cql;
    };
    SQL.update = (tableName, subset, where) => {
        const cql = `UPDATE ${tableName} ` +
            `SET ${subset.map((col, idx) => `"${col}" = $${idx + 1}`).join(", ")} ` +
            `WHERE ${where.map((col, idx) => `"${col}" = $${subset.length + idx + 1}`).join(" AND ")};`;
        return cql;
    };
    SQL.selectAll = (tableName, subset) => {
        const cql = `SELECT ${subset === "*" ? "*" : subset.join(", ")} ` + `FROM ${tableName};`;
        return cql;
    };
    const whereConditionToString = (cond, idx) => {
        if (typeof cond === "string") {
            return `("${cond}" = $${idx + 1})`;
        }
        return cond.toString();
    };
    SQL.select = (tableName, subset, where) => {
        const cql = `SELECT ${subset === "*" ? "*" : subset.map((column) => `"${column}"`).join(", ")}` +
            ` FROM ${tableName}` +
            ` WHERE ${where.map(whereConditionToString).join(" AND ")}` +
            `;`;
        return cql;
    };
    SQL.deleteEntry = (tableName, where) => {
        const cql = `DELETE` +
            ` FROM ${tableName}` +
            ` WHERE ${where.map((column, i) => `("${column}" = $${i + 1})`).join(" AND ")}` +
            `;`;
        return cql;
    };
    SQL.dropTable = (tableName, dropConstraints) => {
        const statements = [];
        if (dropConstraints === true) {
            statements.push(dropAllConstraintsOfTable(tableName));
        }
        statements.push(`DROP TABLE ${tableName};`);
        return statements.join("\n");
    };
    SQL.dropTableColumn = (tableName, column, cascade) => {
        const sql = `
			ALTER TABLE ${tableName}
			DROP COLUMN IF EXISTS ${column} ${cascade === true ? "CASCADE" : ""};
		`;
        return sql;
    };
    SQL.addTableColumn = (tableName, column, ifNotExists = false) => {
        const foreignKeyConstraints = collectForeignKeyConstraints([column]);
        const sql = `
			ALTER TABLE ${tableName}
			ADD COLUMN ${ifNotExists ? "IF NOT EXISTS" : ""} ${prepareCreateColumnStatement(column)};
			${foreignKeyConstraints.length > 0
            ? prepareForeignKeyConstraintStatements(tableName, foreignKeyConstraints)
                .map((stmt) => `ALTER TABLE ${tableName} ADD CONSTRAINT ${stmt};`)
                .join("\n")
            : ""}
		`;
        return sql;
    };
    SQL.dropConstraint = (tableName, col, info) => {
        return (info.foreignKeys || [])
            .map((fkc) => `
				ALTER TABLE ${tableName} DROP CONSTRAINT IF EXISTS ${tableName}_${col}_fkey CASCADE;
			`)
            .join("\n");
    };
    const dropAllConstraintsOfTable = (table) => {
        const sql = `
			SELECT 'ALTER TABLE ${table} DROP CONSTRAINT IF EXISTS "' || relname || '";' as pg_drop
			FROM pg_class
			WHERE (relkind = 'i' OR relkind = 'p' OR relkind = 'f') AND relname LIKE '${table.toLowerCase()}%';
		`;
        return sql;
    };
    SQL.createIndex = (unique, name, column) => {
        const sql = `CREATE ${unique ? "UNIQUE " : ""}INDEX IF NOT EXISTS ${name}_${column}_${unique ? "u" : ""}index ON ${name} (${column});`;
        return sql;
    };
    SQL.raw = (sql, values = []) => ({
        sql,
        values,
    });
    SQL.dropView = (view) => {
        const sql = `DROP VIEW IF EXISTS ${view} CASCADE;`;
        return sql;
    };
    SQL.createView = (view, query) => {
        const sql = `CREATE OR REPLACE VIEW ${view} AS (${query});`;
        return sql;
    };
})(SQL = exports.SQL || (exports.SQL = {}));
const collectForeignKeyConstraints = (columns) => {
    return utils_1.flatten(columns.map((col) => (col.foreignKeys ? col.foreignKeys.map((fkc) => (Object.assign(Object.assign({}, fkc), { column: col.name }))) : [])));
};
const prepareCreateColumnStatement = (col) => {
    const replaceArr = [];
    if (col.defaultValue !== undefined) {
        replaceArr.push(col.defaultValue);
    }
    return (`"${col.name}" ${!col.autoIncrement ? mapColumnType(col) : ""} ` +
        `${col.autoIncrement ? "SERIAL " : ""}` +
        `${col.nullable !== undefined && !col.nullable ? "NOT NULL " : ""}` +
        `${col.defaultValue !== undefined
            ? `DEFAULT ${table_1.isSQLFunction(col.defaultValue) ? col.defaultValue.func : mapValues(col.defaultValue)}`
            : ""}`);
};
const prepareForeignKeyConstraintStatements = (tableName, foreignKeyConstraints) => {
    return foreignKeyConstraints.map((fkc) => `${tableName}_${fkc.column}_fkey
			FOREIGN KEY (${fkc.column}) REFERENCES ${fkc.targetTable} (${fkc.targetColumn})
			${fkc.onDelete !== undefined ? mapUpdateDeleteRule(fkc.onDelete, false) : ""}
			${fkc.onUpdate !== undefined ? mapUpdateDeleteRule(fkc.onUpdate, true) : ""}`);
};
const mapColumnType = (col) => {
    if (table_1.isJSONType(col.type)) {
        return "JSON";
    }
    else if (table_1.isCollection(col.type)) {
        return col.type.type.toUpperCase() + "[]";
    }
    else {
        return col.type.toUpperCase();
    }
};
const mapValues = (val) => {
    if (val === undefined || val === null) {
        return "NULL";
    }
    else if (typeof val === "string") {
        return pg_escape_1.default("%L", val);
    }
    else if (moment_1.default.isMoment(val)) {
        return `'${sql_utils_1.dateToSQLUTCFormat(val.utc().toDate())}'`;
    }
    else if (val instanceof Date) {
        return `'${sql_utils_1.dateToSQLUTCFormat(val)}'`;
    }
    else if (typeof val === "object") {
        return mapValues(JSON.stringify(val));
    }
    else {
        return val;
    }
};
const mapUpdateDeleteRule = (rule, isUpdate) => {
    const prefix = isUpdate ? "UPDATE" : "DELETE";
    switch (rule) {
        case table_1.ForeignKeyUpdateDeleteRule.Cascade:
            return `ON ${prefix} CASCADE`;
        case table_1.ForeignKeyUpdateDeleteRule.NoAction:
            return "";
        case table_1.ForeignKeyUpdateDeleteRule.Restrict:
            return "";
        case table_1.ForeignKeyUpdateDeleteRule.SetDefault:
            return `ON ${prefix} SET DEFAULT`;
        case table_1.ForeignKeyUpdateDeleteRule.SetNull:
            return `ON ${prefix} SET NULL`;
    }
};
//# sourceMappingURL=sql.js.map